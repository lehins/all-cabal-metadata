homepage: ''
changelog-type: text
hash: b1433fc958d6996e97ffdb99cf0fa703b3a4f5565dac39204abcb8fc8c733a68
test-bench-deps:
  exceptions: ! '>=0.8.3'
  bytestring: -any
  test-framework: -any
  stm: ! '>=2.4 && <2.5'
  base: ! '>=4.9 && <4.10'
  time: -any
  text: -any
  filepath: ! '>=1.4.0.0'
  test-framework-quickcheck2: -any
  network: ! '>=2.6.3.1'
  semigroups: ! '>=0.18.2'
  test-framework-th: -any
  liblawless: -any
  binary: ! '>=0.7.5.0'
  transformers: ! '>=0.4.2.0'
  temporary: ! '>=1.2.0.4'
  QuickCheck: -any
  aeson: <1.0
maintainer: evan@theunixman.com
synopsis: Prelude based on protolude for GHC 8 and beyond.
changelog: ! "2016-12-17  Evan Cofsky  <evan@theunixman.com>\n\n\t* liblawless.cabal:
  Add new tests and Arbitrary module.\n\n\t* Tests/TestAesonEncoding.hs: Tests for
  the JSON field encoding\n\tlogic.\n\n\t* Source/Arbitrary.hs: Instances of Arbitrary
  for various useful\n\ttypes.\n\n\t* Tests: Use new Arbitrary instances.\n\n2016-12-16
  \ Evan Cofsky  <evan@theunixman.com>\n\n\t* liblawless.cabal (0.14.0.3):\n\tUse
  dns-2.0.8 which is available in Debian.\n\tUpdate location information for this
  release.\n\n\t* Examples/ZFS/zpools.yaml: Rename from zpool.yaml.\n\n\t* liblawless.cabal:
  Uncomment ZFS example build.\n\n\t* Source/Yaml.hs: Import and export Generics here,
  too.\n\n\t* Examples/ZFS: Create Types, use optics, add Main.hs.\n\n\t* Source/Aeson.hs:
  Rename molude to lawless.\n\n\t* Tests/TestAeson.hs: Rename molude to lawless.\n\n\t*
  liblawless.cabal (0.14.0): Adding Networking library, clearing\n\tup NFC Text, focusing
  more on examples and tests.\n\n\t* Source/Text.hs: Clearer notion of NFC optics
  vs regular Lens\n\toptics.\n\n\t* Source/Networking.hs: Created this file to start
  composing\n\tvarious network libraries together.\n"
basic-deps:
  exceptions: ! '>=0.8.3 && <0.9'
  base-unicode-symbols: ! '>=0.2.2 && <0.3'
  bytestring: ! '>=0.10.8 && <0.11'
  stm: ! '>=2.4.4 && <2.5'
  base: ! '>=4.9 && <4.10'
  time: ! '>=1.6.0 && <1.7'
  managed: -any
  text: ! '>=1.2.2 && <1.3'
  data-textual: ! '>=0.3.0 && <0.4'
  boomerang: ! '>=1.4.5.2 && <1.5'
  network: ! '>=2.6.3.1 && <2.7'
  protolude: ! '>=0.1.10 && <0.2'
  data-default: ! '>=0.7.1.1 && <0.8'
  semigroups: ! '>=0.18.2 && <0.19'
  containers-unicode-symbols: ! '>=0.3.1 && <0.4'
  containers: ! '>=0.5.7 && <0.6'
  parsers: ! '>=0.12.4 && <0.13'
  lens: ! '>=4.14 && <4.15'
  binary: ! '>=0.8.3 && <0.9'
  text-icu: ! '>=0.7.0 && <0.8'
  zippers: ! '>=0.2.2 && <0.3'
  contravariant: ! '>=1.4 && <1.5'
  network-ip: ! '>=0.3 && <0.4'
  mtl: ! '>=2.2.1 && <2.3'
  pathtype: ! '>=0.8 && <0.9'
  transformers: ! '>=0.5.2 && <0.6'
  temporary: ! '>=1.2.0 && <1.3'
  random: ! '>=1.1 && <1.2'
  text-icu-normalized: ! '>=0.3.0 && <0.4'
  QuickCheck: ! '>=2.8.2 && <2.9'
  stm-containers: ! '>=0.2.15 && <0.3'
  text-printer: ! '>=0.4 && <0.5'
  machines: ! '>=0.6.1 && <0.7'
  aeson: ! '>=0.11.2 && <0.12'
  hjsonschema: ! '>=1.2.0 && <1.3'
  dns: ! '>=2.0.8 && <2.1'
all-versions:
- '0.13.0'
- '0.13.1'
- '0.13.2'
- '0.13.3'
- '0.14.0.1'
- '0.14.0.2'
- '0.14.0.3'
- '0.14.0.4'
- '0.16.0'
- '0.16.1'
- '0.17.0'
- '0.17.1'
author: Evan Cofsky
latest: '0.17.1'
description-type: markdown
description: ! "# liblawless: An Effectful Foundation\n\n## Overview\n[liblawless][liblawless]
  is a replacement for the\nstandard [Prelude][prelude]. It targets [GHC 8.0][ghc80]
  and\nnewer. It's core is building a fine-grained but readily accessible\nEffect
  model to move more type checking of code that changes its\nenvironment out of plain
  IO.\n\n[prelude]: http://hackage.haskell.org/package/base\n[liblawless]: https://www.lambdanow.us/wiki/LearningProjects/liblawless\n[ghc80]:
  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html\n\n##
  Pure vs Effectful Functions\nPure functions don't affect the anything outside of
  the function. A\nPure function will run a calculation on the given values, and return
  a\nresult. If you pass in the same parameters, you'll always get the same\nresult
  no matter how many times you call the function.\n\nEffectful functions are functions
  that do affect the program outside\nthe function, and often the environment outside
  the computer running\nthem. Even with the same parameters, Effectful Functions can
  return\ndifferent results. In many cases they can even return signals that\ncompleting
  their task wasn't possible. In many languages these are\ncalled \"Side Effects\",
  and aren't modeled in the type system at\nall. Haskell comes with a simple Effect
  model in its type system,\nthe [io][IO monad].\n\n[io]: http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO\n\n##
  Kinds of Effects\nThe [io][IO monad] models Effects a function has on the world
  outside\nthe program. There are other, more limited Effects as well, and there\nare
  libraries for managing these as well. The two most common are:\n\n- [transformers][Transformers]\n-
  [mtl][The MTL]\n\n[transformers]: http://hackage.haskell.org/package/transformers
  Transformers\n[mtl]: http://hackage.haskell.org/package/mtl\n\nThese model Effects
  that only apply to the current program, while the\nIO monad models ''all other effects''
  on the world. That's a really\nbroad brush. Most bugs in Haskell code are in the
  IO monad.\n\nThis project is implementing several extra types of Effects that\naffect
  the world. Instead of treating them all the same, though, it\nbreaks them up into
  much smaller kinds of Effects. For example, for\naccessing files, it's possible
  to:\n\n- read bytes from a file\n- write bytes to a file\n- read lines of text from
  a file\n- write lines of text from a file\n- read arbitrary data from a file, operate
  on these data items, and\n  write them to a network stream\n- many other simple
  and complex operations\n\nWe are building them on top of the [machines][Machines]
  library. This\nlibrary offers a composable model for connecting strongly-typed\nstreams
  together. It also implements provisions for arbitrary effects,\nand connecting Effectful
  functions with Pure functions into streams of\ncomputations. When combined with
  the [async][Async] library, these\nstreams, and even individual nodes in these streams,
  can be run\nconcurrently and safely, making full use of multicore systems.\n\n[machines]:
  http://hackage.haskell.org/package/machines\n[async]: http://hackage.haskell.org/package/async\n"
license-name: GPL-3
